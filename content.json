{"meta":{"title":"独钓翁","subtitle":"孤舟蓑笠翁，独钓寒江雪。","description":"千山鸟飞绝，万径人踪灭。孤舟蓑笠翁，独钓寒江雪。","author":"等待-希望","url":"http://piggsoft.github.io"},"pages":[{"title":"404","date":"2017-01-02T06:51:00.000Z","updated":"2017-01-03T01:08:11.983Z","comments":true,"path":"404.html","permalink":"http://piggsoft.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2017-01-02T07:25:31.000Z","updated":"2017-01-03T01:08:11.984Z","comments":true,"path":"about/index.html","permalink":"http://piggsoft.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-01-02T04:19:42.000Z","updated":"2017-01-03T01:08:11.985Z","comments":false,"path":"categories/index.html","permalink":"http://piggsoft.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-01-02T04:18:47.000Z","updated":"2017-01-03T01:08:11.999Z","comments":false,"path":"tags/index.html","permalink":"http://piggsoft.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"跟着独钓翁一起学习spring-boot(一)","slug":"跟着独钓翁一起学习spring-boot(一)","date":"2017-01-03T02:05:41.000Z","updated":"2017-01-03T02:53:23.234Z","comments":true,"path":"2017/01/03/跟着独钓翁一起学习spring-boot(一)/","link":"","permalink":"http://piggsoft.github.io/2017/01/03/跟着独钓翁一起学习spring-boot(一)/","excerpt":"相关背景Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。","text":"相关背景Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 多年以来，Spring IO平台饱受非议的一点就是大量的XML配置以及复杂的依赖管理。在去年的SpringOne 2GX会议上，Pivotal的CTO Adrian Colyer回应了这些批评，并且特别提到该平台将来的目标之一就是实现免XML配置的开发体验。Boot所实现的功能超出了这个任务的描述，开发人员不仅不再需要编写XML，而且在一些场景中甚至不需要编写繁琐的import语句。在对外公开的beta版本刚刚发布之时，Boot描述了如何使用该框架在140个字符内实现可运行的web应用，从而获得了极大的关注度，该样例发表在tweet上。 然而，Spring Boot并不是要成为Spring IO平台里面众多“Foundation”层项目的替代者。Spring Boot的目标不在于为已解决的问题域提供新的解决方案，而是为平台带来另一种开发体验，从而简化对这些已有技术的使用。对于已经熟悉Spring生态系统的开发人员来说，Boot是一个很理想的选择，不过对于采用Spring技术的新人来说，Boot提供一种更简洁的方式来使用这些技术。 在追求开发体验的提升方面，Spring Boot，甚至可以说整个Spring生态系统都使用到了Groovy编程语言。Boot所提供的众多便捷功能，都是借助于Groovy强大的MetaObject协议、可插拔的AST转换过程以及内置的依赖解决方案引擎所实现的。在其核心的编译模型之中，Boot使用Groovy来构建工程文件，所以它可以使用通用的导入和样板方法（如类的main方法）对类所生成的字节码进行装饰（decorate）。这样使用Boot编写的应用就能保持非常简洁，却依然可以提供众多的功能 快速开始 访问Spring Initializr 选择构建方式Maven，Spring Boot 版本 填写group，artifact 选择所需依赖，如果不记得依赖的名称，可以点击Switch to the full version. 点击Generate Project， 进行下载。 配置运行 接下压缩包，用你熟悉的ide打开项目 删除mvnw，mvnw.cmd文件和 .mvn目录 编写一个Controller 123456789@Controllerpublic class HomeController &#123; @RequestMapping(\"/\") public void hello(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; response.getWriter().write(\"Hello World\"); &#125;&#125; 运行XXApplication的main方法，访问http://localhost:8080，观看到Hello World，即代表成功。","categories":[{"name":"IT","slug":"IT","permalink":"http://piggsoft.github.io/categories/IT/"}],"tags":[{"name":"Java Spring Spring-Boot","slug":"Java-Spring-Spring-Boot","permalink":"http://piggsoft.github.io/tags/Java-Spring-Spring-Boot/"}]},{"title":"Java进行四则运算","slug":"Java进行四则运算","date":"2016-03-14T16:00:00.000Z","updated":"2017-01-03T01:08:11.984Z","comments":true,"path":"2016/03/15/Java进行四则运算/","link":"","permalink":"http://piggsoft.github.io/2016/03/15/Java进行四则运算/","excerpt":"更加便捷的进行四则运算，且代码足够简单。一般的逻辑是按照正常人的思路来解析，这样难度太大。转换思路和原理，可以参考将中缀表达式转化为后缀表达式","text":"更加便捷的进行四则运算，且代码足够简单。一般的逻辑是按照正常人的思路来解析，这样难度太大。转换思路和原理，可以参考将中缀表达式转化为后缀表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.piggsoft;import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;import java.util.Stack;import java.util.regex.Pattern;public class Arithmetic &#123; //操作符stack private Stack&lt;String&gt; operator = new Stack&lt;String&gt;(); //后缀表达式 private List&lt;String&gt; postFix = new ArrayList&lt;String&gt;(); private Pattern operatorPattern = Pattern.compile(\"[\\\\d\\\\.]\"); private Pattern arithmeticPattern = Pattern.compile(\"[\\\\(\\\\)\\\\+\\\\-/\\\\*]\"); //将中缀表达式换为后缀表达式 public void parse(String s) &#123; s = replace(s); int j = 0; for (int i = 0; i &lt; s.length(); i++) &#123; String temp = s.substring(i, i + 1); if (operatorPattern.matcher(temp).matches()) &#123; continue; &#125; if (arithmeticPattern.matcher(temp).matches()) &#123; j = process(j, i, s, temp); &#125; else if (\"\".equals(temp)) &#123; return; &#125; &#125; if (j &lt; s.length()) &#123; postFix.add(s.substring(j, s.length())); &#125; while (!this.operator.isEmpty()) &#123; postFix.add(operator.pop()); &#125; &#125; private String replace(String s) &#123; return s.replaceAll(\"\\\\s\", \"\"); &#125; private int process(int startIndex, int currentIndex, String str, String word) &#123; if (startIndex != currentIndex) &#123; postFix.add(str.substring(startIndex, currentIndex)); &#125; addOperator(word); startIndex = currentIndex + 1; if (startIndex &gt; str.length()) &#123; startIndex = str.length(); &#125; return startIndex; &#125; public void addOperator(String operator) &#123; if (\"(\".equals(operator)) &#123; &#125; else if (\")\".equals(operator)) &#123; while (!this.operator.isEmpty()) &#123; String temp = this.operator.pop(); if (\"(\".equals(temp)) &#123; break; &#125; else &#123; postFix.add(temp); &#125; &#125; return; &#125; else if (!this.operator.isEmpty()) &#123; while (!this.operator.isEmpty()) &#123; String temp = this.operator.peek(); if (needPop(temp, operator)) &#123; this.postFix.add(this.operator.pop()); &#125; else &#123; break; &#125; &#125; &#125; this.operator.add(operator); &#125; public boolean needPop(String inStackTop, String current) &#123; return getLevel(current.charAt(0)) &lt;= getLevel(inStackTop.charAt(0)); &#125; public int getLevel(char operator) &#123; switch (operator) &#123; case '+': return 1; case '-': return 1; case '*': return 2; case '/': return 2; default: return -1; &#125; &#125; public BigDecimal compute() &#123; Stack&lt;BigDecimal&gt; stack = new Stack&lt;BigDecimal&gt;(); for (int i = 0; i &lt; this.postFix.size(); i++) &#123; if (arithmeticPattern.matcher(postFix.get(i)).matches()) &#123; BigDecimal bd2 = stack.pop(); BigDecimal bd1 = stack.pop(); BigDecimal temp = compute(postFix.get(i).charAt(0), bd1, bd2); stack.add(temp); &#125; else &#123; stack.add(new BigDecimal(postFix.get(i))); &#125; &#125; return stack.pop(); &#125; private BigDecimal compute(char operator, BigDecimal bd1, BigDecimal bd2) &#123; switch (operator) &#123; case '+': return bd1.add(bd2); case '-': return bd1.subtract(bd2); case '*': return bd1.multiply(bd2); case '/': return bd1.divide(bd2);//应当使用bd1.divide(divisor, scale, roundingMode); default: return null; &#125; &#125; public static void main(String[] args) &#123; Arithmetic arithmetic = new Arithmetic(); arithmetic.parse(\"9 + (3 - 1) * 3 + 10 / 2\"); System.out.println(arithmetic.postFix); System.out.println(arithmetic.compute()); arithmetic = new Arithmetic(); arithmetic.parse(\"9 + (3 - 1) * 3 + 10 / 2 + 1000 - 200 - (100 + 5 - 9 / 3)\"); System.out.println(arithmetic.postFix); System.out.println(arithmetic.compute()); arithmetic = new Arithmetic(); arithmetic.parse(\"9 + (3 - 1) * 3 + 10 / 2 + 1000 - 200 - (100 + 5 - 9 / 3)\"); System.out.println(arithmetic.postFix); System.out.println(arithmetic.compute()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://piggsoft.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://piggsoft.github.io/tags/Java/"},{"name":"Math","slug":"Math","permalink":"http://piggsoft.github.io/tags/Math/"}]},{"title":"Windows指定部分IP走VPN通道","slug":"Windows指定部分IP走VPN通道","date":"2015-05-12T16:00:00.000Z","updated":"2017-01-03T01:54:09.511Z","comments":true,"path":"2015/05/13/Windows指定部分IP走VPN通道/","link":"","permalink":"http://piggsoft.github.io/2015/05/13/Windows指定部分IP走VPN通道/","excerpt":"因为工作需要可能要在机器连接公司的VPN，但一般情况下连了VPN就无法连接到外网了，本文主要是讲解如何在Windows上配置，从而让固定ip走VPN，其余走本地网络。","text":"因为工作需要可能要在机器连接公司的VPN，但一般情况下连了VPN就无法连接到外网了，本文主要是讲解如何在Windows上配置，从而让固定ip走VPN，其余走本地网络。 按照正常流程配置好VPN 在vpn连接属性–&gt;网络–&gt;Internet协议版本4–&gt;属性–&gt;高级–&gt;去掉《在远程网络上使用默认网关》；这样做让所有连接都走本地网络连接，不走vpn。 连接vpn，获取vpn分配的ip 输入命令： 1$&gt;ipconfig 结果如下： 12345PPP 适配器 FUIOU VPN 连接: 连接特定的 DNS 后缀 . . . . . . . : IPv4 地址 . . . . . . . . . . . . : 192.168.18.101 子网掩码 . . . . . . . . . . . . : 255.255.255.255 默认网关. . . . . . . . . . . . . : 添加route解析 1route add -p 192.168.8.22 mask 255.255.255.255 192.168.18.101 metric 2 192.168.8.22 –&gt;想要通过vpn访问的ip 192.168.18.101 –&gt; 上面vpn分配的ip 在命令行中加入这个命令。使用下面命令进行测试 ping 192.168.8.22至此配置完成，既可以访问外网，又可以访问192.168.8.22这个VPN地址","categories":[{"name":"IT","slug":"IT","permalink":"http://piggsoft.github.io/categories/IT/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://piggsoft.github.io/tags/Windows/"},{"name":"VPN","slug":"VPN","permalink":"http://piggsoft.github.io/tags/VPN/"}]}]}